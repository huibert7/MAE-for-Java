import java.awt.*;import java.awt.image.*;import java.applet.*;import java.util.*;abstract class NewWindow extends Object{	public		String					title;	public  	boolean					visible,highlighted,drag,zoombox,closebox,growbox,modal,deleted;	public		Rectangle				zoomRect = new Rectangle();	public		Rectangle				closeRect = new Rectangle();	public		Rectangle				growRect = new Rectangle();	public		Vector					theControls = new Vector();	public		int						xPos,yPos,width,height;	public		Rectangle				userState;	public		Rectangle				stdState;	public		int						refCon;	protected	Image					graphicsPort;	protected	Graphics				graphicsPortGC;	protected 	Desktop					theDesktop;	protected	MAE						theApplet;	protected	AppleFoundationClasses	AFC;	protected	int						titleWidth,fontHeight;		private		int						xRelPos,yRelPos,xCurPos,yCurPos;	private		int						previousX,previousY;	protected	static	Color			borderGray = new Color(82,82,82);	protected	static	Color			lightGray = new Color(189,189,189);	protected	static	Color			lighterGray = new Color(239,239,239);	protected	static	Color			midGray = new Color(115,115,115);	protected	static	Color			textGray = new Color(132,132,132);	protected	static	Color			lightBlue = new Color(206,206,255);	protected	static	Color			midBlue = new Color(165,165,214);	protected	static	Color			darkBlue = new Color(123,123,156);	protected	static	FontMetrics		fm;	protected	static	Font			helvFont = new Font("Helvetica", Font.BOLD, 12);	public void NewWindow()	{		graphicsPort = null;		graphicsPortGC = null;	}		public void Add2Desktop(String theTitle, int x, int y, int w, int h, boolean vis, boolean goAway, Desktop desk, MAE app, int theRefCon)	{		theDesktop = desk;		theApplet = app;		AFC = theApplet.ApplicationThread.AFC;				title = theTitle;		xPos = x;		yPos = y;		width = w;		height = h;		visible = vis;		closebox = goAway;		refCon = theRefCon;		CreatePorts(width,height);		fm = graphicsPortGC.getFontMetrics(graphicsPortGC.getFont());		fontHeight = fm.getMaxAscent()+fm.getMaxDescent();				stdState = new Rectangle(3,21+2,theDesktop.DesktopWidth-3,theDesktop.DesktopHeight - 2);		userState = new Rectangle(x,y,x+width-1,y+height-1);				if (zoombox)		{			zoomRect.x = this.width - 20;			zoomRect.y = 4;			zoomRect.width = 11;			zoomRect.height = 11;		}		if (closebox)		{			closeRect.x = 9;			closeRect.y = 4;			closeRect.width = 11;			closeRect.height = 11;		}		if (growbox)		{			growRect.width = 14;			growRect.height = 14;		}		if (theTitle.equals(""))		{			titleWidth = 0;		}		else		{			titleWidth = fm.stringWidth(theTitle) +10;		}				DrawWindow();		Init();		Activate();		Redraw();	}		private void DrawWindow()	{		graphicsPortGC.setColor(Color.white);		graphicsPortGC.fillRect(0,0,width-1,height-1);				DrawFrame();		Draw();		DrawControls();		DrawGrowIcon();	}		abstract protected void Redraw();		abstract protected void DrawFrame();		abstract protected void DrawTitle();	abstract protected void CreatePorts(int width,int height);		abstract void Init();	abstract void Draw();		abstract void DrawGrowIcon();		abstract void Activate();		abstract void userActivate();		abstract void Deactivate();		abstract void userDeactivate();		abstract void Close();		abstract Point GlobalToLocal(Point thePoint);		abstract protected void DisposePorts();		abstract protected void DrawGraphicsPort();	public Graphics getGraphicsPort()	{		return graphicsPortGC;	}		public void UpdateGraphicsPort()	{		int			i = 0;		NewWindow	Temp;		boolean		okDraw = false;				if (AFC.FrontWindow() == this)		{			DrawGraphicsPort();			theDesktop.Redraw();		}		else		{			while (i < AFC.theWindows.size())			{				Temp = (NewWindow)AFC.theWindows.elementAt(i);				if (!okDraw)				{					if (this == Temp)					{						okDraw = true;						DrawGraphicsPort();					}				}				else Temp.Redraw();				i++;			}			theDesktop.Redraw();		}	}		public void HiliteWindow(boolean state)	{		if (state)		{			if (!highlighted) highlighted = true;			DrawFrame();			Redraw();		}		else		{			if (highlighted) highlighted = false;			DrawFrame();			Redraw();		}	}		public void SelectWindow()	{		Enumeration	e;		Control	TempControl;				if (!visible) visible = true;		HiliteWindow(true);		e = theControls.elements();		while (e.hasMoreElements())		{			TempControl = (Control)e.nextElement();			TempControl.hiliteState = 255;			TempControl.Draw();		}		Activate();		BringToFront();	}		public void BringToFront()	{		Enumeration	e;		NewWindow	Temp;		int			i;				i = 0;								// Internal cleanup. Make sure no deleted windows remain in the list		while (i<AFC.theWindows.size())		{			Temp = (NewWindow)AFC.theWindows.elementAt(i);			if (Temp.deleted) AFC.theWindows.removeElementAt(i);			else i++;		}		i = 0;		e = AFC.theWindows.elements();		while (e.hasMoreElements())		{			Temp = (NewWindow)e.nextElement();			if (Temp == this)			{				AFC.theWindows.removeElementAt(i);				break;			}			else			{				if (Temp.highlighted) Temp.HiliteWindow(false);			}			i++;		}		while (i<AFC.theWindows.size())		{			Temp = (NewWindow)AFC.theWindows.elementAt(i);			if (Temp.highlighted)			{				Temp.HiliteWindow(false);				Temp.Deactivate();			}			i++;		}		AFC.theWindows.addElement(this);		Redraw();		AFC.theMenuBar.Redraw();		theDesktop.Redraw();	}		public void SendBehind(NewWindow theWindow)	{		Enumeration	e,f;		NewWindow	Temp;		Control		TempControl;		int			i;				i = 0;		e = AFC.theWindows.elements();		while (e.hasMoreElements())		{			Temp = (NewWindow)e.nextElement();			if (Temp == this)			{				AFC.theWindows.removeElementAt(i);				break;			}			i++;		}		if (theWindow == null) AFC.theWindows.insertElementAt(this,0);		else		{			i = 0;			e = AFC.theWindows.elements();			while (e.hasMoreElements())			{				Temp = (NewWindow)e.nextElement();				if (Temp == theWindow)				{					AFC.theWindows.insertElementAt(this,i);					break;				}				i++;			}		}		AFC.FrontWindow().SelectWindow();	}			public void DragWindow(Point thePoint)	{		Graphics	g;		int			x,y;				g = theDesktop.getGraphics();		g.drawImage(theDesktop.offScreenImage,0,0,null);		g.setColor(Color.white);		g.setXORMode(Color.black);		g.drawLine(xPos-1,yPos-1,xPos+width,yPos-1);		g.drawLine(xPos-1,yPos+height,xPos+width,yPos+height);		g.drawLine(xPos-1,yPos,xPos-1,yPos+height-1);		g.drawLine(xPos+width,yPos,xPos+width,yPos+height-1);				xRelPos = thePoint.x-xPos;		yRelPos = thePoint.y-yPos;		xCurPos = xPos;		yCurPos = yPos;		do		{					x = AFC.xMousePos;			y = AFC.yMousePos;						if (x-xRelPos != xCurPos | y-yRelPos != yCurPos)			{				if (y - yRelPos<=21) y = 22 + yRelPos;				g.drawLine(xCurPos-1,yCurPos-1,xCurPos+width,yCurPos-1);				g.drawLine(xCurPos-1,yCurPos+height,xCurPos+width,yCurPos+height);				g.drawLine(xCurPos-1,yCurPos,xCurPos-1,yCurPos+height-1);				g.drawLine(xCurPos+width,yCurPos,xCurPos+width,yCurPos+height-1);				xCurPos = x-xRelPos;				yCurPos = y-yRelPos;				g.drawLine(xCurPos-1,yCurPos-1,xCurPos+width,yCurPos-1);				g.drawLine(xCurPos-1,yCurPos+height,xCurPos+width,yCurPos+height);				g.drawLine(xCurPos-1,yCurPos,xCurPos-1,yCurPos+height-1);				g.drawLine(xCurPos+width,yCurPos,xCurPos+width,yCurPos+height-1);			}		}		while (!AFC.WaitMouseUp());			g.setPaintMode();		MoveWindow(x-xRelPos,y-yRelPos,false);	}		public void MoveWindow(int x,int y,boolean front)	{		MoveWindow2(x,y);						userState.x = xPos;		userState.y = yPos;		userState.width = xPos+width-1;		userState.height = yPos+height-1;		if (front) SelectWindow();		else theDesktop.Redraw();	}		public void MoveWindow2(int x,int y)	{		int			x2,y2,x3,y3,i;		boolean		done = false;		NewWindow	Temp;				x2 = xPos;		if (x2<0) x2 = 0;		if (x2 % 2 == 1) x2--;		y2 = yPos;		if (y2 % 2 == 0) y2--;		for (y3 = y2 ; y3 < yPos + height +1; y3 = y3 + 40) for (x3 = x2; x3 < xPos + width + 1; x3 = x3 + 40)		if (!(x3>x && x3+40<x+width && y3>y && y3+40<y+height)) theDesktop.offScreenImageGC.drawImage(theDesktop.theDesktop,x3,y3,null);		xPos = x;		yPos = y;		i=0;		while (i<AFC.theWindows.size())		{			Temp = (NewWindow)AFC.theWindows.elementAt(i);			if (Temp.visible) Temp.Redraw();			i++;		}	}		public long GrowWindow(Point thePoint,Rectangle theRect)	{		Graphics	g;		int			x,y;				g = theDesktop.getGraphics();		g.setColor(Color.white);		g.setXORMode(Color.black);		g.drawLine(xPos-1,yPos-1,xPos+width,yPos-1);		g.drawLine(xPos,yPos+18,xPos+width-1,yPos+18);		g.drawLine(xPos-1,yPos+height,xPos+width,yPos+height);		g.drawLine(xPos,yPos+height-16,xPos+width-1,yPos+height-16); // horiz line for grow		g.drawLine(xPos-1,yPos,xPos-1,yPos+height-1);		g.drawLine(xPos+width,yPos,xPos+width,yPos+height-1);		g.drawLine(xPos+width-17,yPos+19,xPos+width-17,yPos+height-17);		g.drawLine(xPos+width-17,yPos+height-15,xPos+width-17,yPos+height-1);				xRelPos = xPos+width-thePoint.x;		yRelPos = yPos+height-thePoint.y;		previousX = thePoint.x;		previousY = thePoint.y;		do		{			x = AFC.xMousePos;			y = AFC.yMousePos;						if (x != previousX | y != previousY)			{				g.drawLine(xPos-1,yPos-1,previousX+xRelPos,yPos-1);				g.drawLine(xPos,yPos+18,previousX+xRelPos-1,yPos+18);				g.drawLine(xPos-1,previousY+yRelPos,previousX+xRelPos,previousY+yRelPos);				g.drawLine(xPos,previousY+yRelPos-16,previousX+xRelPos-1,previousY+yRelPos-16);				g.drawLine(xPos-1,yPos,xPos-1,previousY+yRelPos-1);				g.drawLine(previousX+xRelPos,yPos,previousX+xRelPos,previousY+yRelPos-1);				g.drawLine(previousX+xRelPos-17,yPos+19,previousX+xRelPos-17,previousY+yRelPos-17);				g.drawLine(previousX+xRelPos-17,previousY+yRelPos-15,previousX+xRelPos-17,previousY+yRelPos-1);					if (x+xRelPos-xPos>theRect.height) x = xPos + theRect.height - xRelPos; // maxWidth check				if (y+yRelPos-yPos>theRect.width) y = yPos + theRect.width - yRelPos;	// maxHeight check				if (x+xRelPos-xPos<theRect.x) x = xPos + theRect.x - xRelPos;			// minWidth check				if (y+yRelPos-yPos<theRect.y) y = yPos + theRect.y - yRelPos;			// minHeight check				g.drawLine(xPos-1,yPos-1,x+xRelPos,yPos-1);				g.drawLine(xPos,yPos+18,x+xRelPos-1,yPos+18);				g.drawLine(xPos-1,y+yRelPos,x+xRelPos,y+yRelPos);				g.drawLine(xPos,y+yRelPos-16,x+xRelPos-1,y+yRelPos-16);				g.drawLine(xPos-1,yPos,xPos-1,y+yRelPos-1);				g.drawLine(x+xRelPos,yPos,x+xRelPos,y+yRelPos-1);				g.drawLine(x+xRelPos-17,yPos+19,x+xRelPos-17,y+yRelPos-17);				g.drawLine(x+xRelPos-17,y+yRelPos-15,x+xRelPos-17,y+yRelPos-1);				previousX = x;				previousY = y;			}		}		while (!AFC.WaitMouseUp());		g.drawLine(xPos-1,yPos-1,previousX+xRelPos,yPos-1);		g.drawLine(xPos,yPos+18,previousX+xRelPos-1,yPos+18);		g.drawLine(xPos-1,previousY+yRelPos,previousX+xRelPos,previousY+yRelPos);		g.drawLine(xPos,previousY+yRelPos-16,previousX+xRelPos-1,previousY+yRelPos-16);		g.drawLine(xPos-1,yPos,xPos-1,previousY+yRelPos-1);		g.drawLine(previousX+xRelPos,yPos,previousX+xRelPos,previousY+yRelPos-1);		g.drawLine(previousX+xRelPos-17,yPos+19,previousX+xRelPos-17,previousY+yRelPos-17);		g.drawLine(previousX+xRelPos-17,previousY+yRelPos-15,previousX+xRelPos-17,previousY+yRelPos-1);		g.setPaintMode();		return (x+xRelPos-xPos)*65536 + (y+yRelPos-yPos);	}		public void SizeWindow(int newWidth, int newHeight)	{		SizeWindow2(newWidth,newHeight);		theDesktop.Redraw();		userState.width = xPos+width-1;		userState.height = yPos+height-1;	}		private void SizeWindow2(int newWidth, int newHeight)	{		Enumeration	e;		NewWindow	Temp;		boolean		okDraw;		int			x,y,x2,y2;		if (newWidth != width && newHeight != height)		{			DisposePorts();			CreatePorts(newWidth,newHeight);			if (newWidth<width || newHeight<height) // redraw what is under the window only if necessary			{				if (newWidth<width)  // minimize desktop update surface				{					x = xPos+newWidth;					if (x%2 != 0) x--;					y = yPos;					if (y%2 == 0) y--;					for (y2 = y; y2<yPos+height; y2 = y2+40) for (x2 = x; x2<xPos+width; x2 = x2+40) theDesktop.offScreenImageGC.drawImage(theDesktop.theDesktop,x2,y2,null);				}				if (newHeight<height)				{					x = xPos;					if (x<0) x=0;					if (x%2 != 0) x--;					y = yPos + newHeight;					if (y%2 == 0) y--;					for (y2 = y; y2<yPos+height; y2 = y2+40) for (x2 = x; x2<xPos+width; x2 = x2+40) theDesktop.offScreenImageGC.drawImage(theDesktop.theDesktop,x2,y2,null);				}				width = newWidth;				height = newHeight;				DrawWindow();							e = AFC.theWindows.elements();				while (e.hasMoreElements())				{					Temp = (NewWindow)e.nextElement();					Temp.Redraw();				}			}			else			{				width = newWidth;				height = newHeight;				DrawWindow();							okDraw = false;				e = AFC.theWindows.elements();				while (e.hasMoreElements())				{					Temp = (NewWindow)e.nextElement();					if (Temp == this) okDraw = true;					if (okDraw) Temp.Redraw();				}			}			AFC.theMenuBar.Redraw();		}	}		public void ZoomWindow(int partCode,boolean front)	{		switch (partCode)		{			case (7):	// zoomIn, set standard state			{ 				MoveWindow2(stdState.x,stdState.y);				SizeWindow2 (stdState.width-stdState.x+1,stdState.height-stdState.y+1);				break;			}			case (8):	// zoomOut, set user state			{		 		MoveWindow2(userState.x,userState.y);				SizeWindow2 (userState.width-userState.x+1,userState.height-userState.y+1);				break;			}		}		if (front) SelectWindow();		else theDesktop.Redraw();	}		public void DrawControls()	{		Enumeration	e;		Control		Temp;				e = theControls.elements();		while (e.hasMoreElements())		{			Temp = (Control)e.nextElement();			if (Temp.visible) Temp.Draw();		}	}	public boolean inWindow(int x,int y)	{		if (visible & x>=xPos & x<(xPos+width) & y>=yPos & y<(yPos+height)) return true;		else return false;	}		public void HideWindow()	{		if (this.visible)		{			ShowHide(false);			if (AFC.FrontWindow() != null) AFC.FrontWindow().SelectWindow();			else			{		 		theDesktop.Redraw();			}		}	}		public void ShowWindow()	{		if (!this.visible)		{			ShowHide(true);			AFC.FrontWindow().SelectWindow();		}	}		public void ShowHide(boolean showFlag)	{		Enumeration	e;		NewWindow	Temp;		boolean		okDraw = false;		int			x2,y2,x3,y3;				if (showFlag)		{			if (!this.visible)			{				this.visible = true;				e = AFC.theWindows.elements();				while (e.hasMoreElements())				{					Temp = (NewWindow)e.nextElement();					if (Temp == this) okDraw = true;					if (Temp.visible && okDraw) Temp.Redraw();				}			}		}		else		{			if (this.visible)			{				x2 = xPos;				if (x2<0) x2=0;				if (x2 % 2 == 1) x2--;				y2 = yPos;				if (y2 % 2 == 0) y2--;				for (y3 = y2 ; y3 < yPos + height +1; y3 = y3 + 40) for (x3 = x2; x3 < xPos + width + 1; x3 = x3 + 40)					theDesktop.offScreenImageGC.drawImage(theDesktop.theDesktop,x3,y3,null);				this.visible = false;				e = AFC.theWindows.elements();				while (e.hasMoreElements())				{					Temp = (NewWindow)e.nextElement();					if (Temp.visible) Temp.Redraw();				}			}		}	}		public void NewControl(Control theControl,Rectangle theRect,String theTitle,boolean isVisible,int value,int min,int max,int theRefCon)	{		theControls.addElement(theControl);		theControl.add2Window(new Rectangle(theRect.x,theRect.y,theRect.width-theRect.x,theRect.height-theRect.y),theTitle,isVisible,value,min,max,theRefCon,this);	}		public FindControlResult FindControl(Point thePoint)	{		Enumeration	e;		Control		Temp;				e = theControls.elements();		while (e.hasMoreElements())		{			Temp = (Control)e.nextElement();			if (thePoint.x >= Temp.xPos & thePoint.x < Temp.xPos+Temp.width & thePoint.y >= Temp.yPos & thePoint.y < Temp.yPos+Temp.height & Temp.visible & Temp.hiliteState == 255)			{				if (Temp instanceof NewButton) return new FindControlResult(10,Temp);				if (Temp instanceof NewCheckBox) return new FindControlResult(11,Temp);				if (Temp instanceof NewRadioButton) return new FindControlResult(11,Temp);			}		}		return new FindControlResult(0,null);	}		public void DisposeControl(Control theControl)	{	}		public void KillControls()	{		while (theControls.size() > 0)		{			theControls.removeElementAt(0);		}	}		public void CloseWindow()	{		Close();		HideWindow();		KillControls();		deleted = true;		DisposePorts();	}}